use std/collections/hashmap;
use std/collections/hashset;
use std/collections/array;
use std/split;
use std/cast;
use std/io;

use util;

fn dfs(string[] grid, HashSet<i32> *v, i32 r, i32 c, i32 p) {
    let stack = [encode2(r, c)];
    let a = HashSet::new<i32>();

    while !stack.is_empty() {
        let encoded = stack.pop();
        let decoded = decode2<i32>(encoded);
        let x = decoded[0];
        let y = decoded[1];

        if (v.contains(encoded)) || (x < 0) || (x >= grid.len())
            || (y < 0) || (y >= grid[0].len()) || (grid[x][y] != p) {
            continue;
        }

        v.add(encoded);
        a.add(encoded);

        for d in [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]] {
            i32 encoded = encode2(d[0], d[1]);

            if !v.contains(encoded) {
                stack.push(encoded);
            }
        }
    }

    return a;
}

fn solution(string[] grid, bool part2) {
    HashMap<i32, HashSet<i32> *[]> *rs = HashMap::new();
    let v = HashSet::new<i32>();
    let res = 0;

    for let r = 0; r < grid.len(); r += 1 {
        for let c = 0; c < grid[0].len(); c += 1 {
            if !v.contains(encode2<i32>(r, c)) {
                HashSet<i32> *area = dfs(grid, v, r, c, grid[r][c]);

                if !rs.contains_key(grid[r][c]) {
                    rs[grid[r][c]] = Array::new<HashSet<i32> *>();
                }

                rs[grid[r][c]].push(area);
            }
        }
    }

    for key in rs.keys() {
        let value = rs[key];

        for set in value {
            let area = set.values();
            let bc = 0;
            let sc = 0;

            for item in area {
                let p = decode2(item);

                let nds = [
                    [p[0] + dir4[0][0], p[1] + dir4[0][1]],
                    [p[0] + dir4[1][0], p[1] + dir4[1][1]],
                    [p[0] + dir4[2][0], p[1] + dir4[2][1]],
                    [p[0] + dir4[3][0], p[1] + dir4[3][1]],
                ];

                for d in nds {
                    if !area.contains(encode2(d[0], d[1])) {
                        bc += 1;
                    }
                }
            }

            for d in dir4 {
                let s = HashSet::new<i32>();

                for item in area {
                    let p = decode2<i32>(item);
                    let encoded = encode2<i32>(p[0] + d[0], p[1] + d[1]);

                    if !area.contains(encoded) {
                        s.add(encoded);
                    }
                }

                let sr = HashSet::new<i32>();
                let sv = s.values();

                for item in sv {
                    let p = decode2<i32>(item);
                    let x = encode2<i32>(p[0] + d[1], p[1] + d[0]);

                    while sv.contains(x) {
                        sr.add(x);

                        let de = decode2<i32>(x);
                        x = encode2<i32>(de[0] + d[1], de[1] + d[0]);
                    }
                }

                sc += s.size() - sr.size();
            }

            if part2 {
                res += area.len() * sc;
            } else {
                res += area.len() * bc;
            }
        }
    }

    return res;
}

fn main(i32 argc, string *argv) {
    let contents = io::read_to_string(argv[1]);
    let grid = contents.split("\n");
    io::dbg(solution(grid, false));
    io::dbg(solution(grid, true));
}
